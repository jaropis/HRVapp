{
    "collab_server" : "",
    "contents" : "### This file is part of PCSS's Time Series suite.\n\n### Time Series is free software: you can redistribute it and/or modify\n### it under the terms of the GNU General Public License as published by\n### the Free Software Foundation, either version 3 of the License, or\n### (at your option) any later version.\n\n### Time Series is distributed in the hope that it will be useful,\n### but WITHOUT ANY WARRANTY; without even the implied warranty of\n### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n### GNU General Public License for more details.\n\n### You should have received a copy of the GNU General Public License\n### along with Time Series.  If not, see <http://www.gnu.org/licenses/>.\n### Time Series is free software: you can redistribute it and/or modify\n### it under the terms of the GNU General Public License as published by\n### the Free Software Foundation, either version 3 of the License, or\n### (at your option) any later version.\n\n### Time Series is distributed in the hope that it will be useful,\n### but WITHOUT ANY WARRANTY; without even the implied warranty of\n### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n### GNU General Public License for more details.\n\n### You should have received a copy of the GNU General Public License\n### along with Time Series.  If not, see <http://www.gnu.org/licenses/>.\n\nsplitOnAnnot <- function(signal, annotations){\n  ### this function splits the signal time series into disjoint subseries, breaking the signal on annotations\n  ### which are not 0\n  badIdx <- which(annotations != 0)\n  if (length(badIdx) == 0)\n    return(list(signal))\n  start <- 1\n  signalSegments <- list()\n  for (idx in badIdx){\n    end <- idx\n    if (start<=end-1)\n      signalSegments <- c(signalSegments, list(signal[start:end-1]))\n    start <- idx+1\n  }\n  #the last run has been rejected automatically, now let us remove the first run (we do not know where it started -- possibly before the beginning of the recording, and we do not know where the last run ended, possibly after the end of the recording)\n  if (annotations[length(annotations)]==0)\n    signalSegments <- c(signalSegments, list(signal[start:length(signal)]))\n  return(signalSegments)\n}\n\ncountRuns <- function(signal, allRuns = list(), directions = c()){\n  ## allRuns - this list keeps all the runs in order\n  ## directions - this vector keeps the designation - whether the run in the allRuns list is a Upeleration or aceleration or noChange\n  # 1 is for Upeleration, 0 for no change, -1 for Downeleration\n  #cusignalent <- ifelse(signal[1]==signal[2],0, ifelse(signal[1]<signal[2], 1, -1)) \n  if (length(signal)<2)\n    stop(\"the lenght of the time series must be greater than 1\")## signal must be longer than 1, or runs make no sense\n  last <- ifelse(signal[1]==signal[2],0, ifelse(signal[1]<signal[2], 1, -1)) \n  begin <- 1\n  for (index in seq(length = (length(signal)-2))+1){\n    cusignalent <- ifelse(signal[index]==signal[index+1],0, ifelse(signal[index]<signal[index+1], 1, -1)) \n    if (cusignalent != last){\n      if (last == -1){\n        allRuns <- c(allRuns, list(signal[(begin):index]))\n        directions <- c(directions, \"Down\")\n      }\n      if (last == 0){\n        allRuns <- c(allRuns, list(signal[(begin):index]))\n        directions <- c(directions, \"noChange\")\n      }\n      if (last == 1){\n        allRuns <- c(allRuns, list(signal[(begin):index]))\n        directions<- c(directions, \"Up\")\n      } \n      begin <- index+1\n      last <- cusignalent\n    }\n  }\n  #now check the last run\n  \n  if (last == -1){\n    allRuns <- c(allRuns, list(signal[(begin):length(signal)]))\n    directions <- c(directions, \"Down\")\n  }\n  if (last == 0){\n    allRuns <- c(allRuns, list(signal[(begin):length(signal)]))\n    directions <- c(directions, \"noChange\")\n  }\n  if (last == 1){\n    allRuns <- c(allRuns, list(signal[(begin):length(signal)]))\n    directions <- c(directions, \"Up\")\n  } \n  return(list(allRuns = allRuns, directions = directions))\n}\n\nsplitAllIntoRuns <- function(signal, annotations){\n  listOfSeparateSegments <- splitOnAnnot(signal, annotations)\n  ### initialize the list keeping separate runs in consecutive segments\n  separateRunsAndDirections <- list(allRuns = list(), directions = c())\n  for (segment in listOfSeparateSegments){\n    if (length(segment)>1){\n      temp <- countRuns(segment)\n      separateRunsAndDirections$allRuns <- c(separateRunsAndDirections$allRuns, temp$allRuns)\n      separateRunsAndDirections$directions <- c(separateRunsAndDirections$directions, temp$directions)\n    }\n  }\n  return(separateRunsAndDirections)\n}\n\ncountForAll <- function(signal, annotations){\n  ### THIS IS THE MAIN FUNCTION OF THIS SOURCEFILE\n  ## this functon counts all the runs of a specific type (Uplerations, directiondown, no change)\n  ## up to the maximum values\n  ## e.g. if there is only one Upeleration runs of the type 1 2 3 4 5, the result will be\n  ## directionup = c(0,0,0,0,1), directiondown = NULL, noChange = NULL\n  splitsignal <- splitAllIntoRuns(signal, annotations)\n  directions <- splitsignal$directions\n  UpRuns <- splitsignal$allRuns[directions == \"Up\"]\n  DownRuns <- splitsignal$allRuns[directions == \"Down\"]\n  noChangeRuns <- splitsignal$allRuns[directions == \"noChange\"]\n  UpRunsCounts <- unlist(lapply(UpRuns, length))\n  DownRunsCounts <- unlist(lapply(DownRuns, length))\n  noChangeRunsCounts <- unlist(lapply(noChangeRuns, length))\n  \n  ## getting maximum lengths of the respective runs\n  maxUp <- ifelse(length(UpRunsCounts>0), max(UpRunsCounts), 0)\n  maxDown <- ifelse(length(DownRunsCounts>0), max(DownRunsCounts), 0)\n  maxNoChange <- ifelse(length(noChangeRunsCounts)>0, max(noChangeRunsCounts), 0)\n  \n  ## now counting\n  upRunsCounts <- c()\n  downRunsCounts <- c()\n  zeroChangeRunsCounts <- c()\n  \n  #directionup\n  for (idxUp in seq(length = maxUp)){\n    upRunsCounts <- c(upRunsCounts, sum(UpRunsCounts == idxUp))\n  }\n  for (idxDown in seq(length = maxDown)){\n    downRunsCounts <- c(downRunsCounts, sum(DownRunsCounts == idxDown))\n  }\n  for (idxNoChange in seq(length = maxNoChange)){\n    zeroChangeRunsCounts <- c(zeroChangeRunsCounts, sum(noChangeRunsCounts == idxNoChange))\n  }\n  return(list(directionup = upRunsCounts, directiondown = downRunsCounts, noChange = zeroChangeRunsCounts))\n}\n\n",
    "created" : 1436466312325.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3414509371",
    "id" : "3802802F",
    "lastKnownWriteTime" : 1438895909,
    "path" : "D:/Dropbox/Praca/granty/PCSS/ts-applications/runs/runs.R",
    "project_path" : "runs.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}