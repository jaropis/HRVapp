{
    "collab_server" : "",
    "contents" : "### runs is free software: you can redistribute it and/or modify\n### it under the terms of the GNU General Public License as published by\n### the Free Software Foundation, either version 3 of the License, or\n### (at your option) any later version.\n\n### runs is distributed in the hope that it will be useful,\n### but WITHOUT ANY WARRANTY; without even the implied warranty of\n### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n### GNU General Public License for more details.\n\n### You should have received a copy of the GNU General Public License\n### along with Time Series.  If not, see <http://www.gnu.org/licenses/>.\n### Time Series is free software: you can redistribute it and/or modify\n### it under the terms of the GNU General Public License as published by\n### the Free Software Foundation, either version 3 of the License, or\n### (at your option) any later version.\n\n### Time Series is distributed in the hope that it will be useful,\n### but WITHOUT ANY WARRANTY; without even the implied warranty of\n### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n### GNU General Public License for more details.\n\n### You should have received a copy of the GNU General Public License\n### along with Time Series.  If not, see <http://www.gnu.org/licenses/>.\n\nlibrary(shiny)\nlibrary(XLConnect)\n### switching off the scientific notation\noptions(scipen=999)\n### so that the rnorm function is called only once during the session\n### these are the starting values of the application\nreadNumbersFromField <- function(listArgument){\n  listOfNamesAndNumbers <- paste(strsplit(listArgument, \",\")[[1]], collapse=\".\")\n  listOfNamesAndNumbers <- strsplit(listOfNamesAndNumbers,\" \")[[1]]\n  nazwa <- \"\"\n  myLengthosc <- length(listOfNamesAndNumbers)\n  for (element in 1:myLengthosc){\n    ## jezeli element nie jest liczba,to dolacz go do nNames i szukaj dalej\n    if (is.na(as.numeric(listOfNamesAndNumbers[element]))) nazwa <- paste(nazwa, listOfNamesAndNumbers[element])\n    else break\n  }\n  listOfNumbers <- listOfNamesAndNumbers[element:myLengthosc]\n  ## indeksy.przecinkow <- agrep(input$numbers, \",\")\n  ##input$variable <- nazwa\n  myData <- as.vector(sapply(listOfNumbers, as.numeric))\n  return(myData)\n}\n\ngetRunsResults <- function(fileAddresses, separator = \"\\t\", data_columns, minmax, usingExcel){\n  javaerror <- FALSE; csverror <- FALSE\n  source(\"runs.R\")\n  results <- list()\n  column_idx <- readNumbersFromField(data_columns)\n  RR_idx <- column_idx[1]\n  flag_idx <- ifelse(length(column_idx)>1, column_idx[2], 0)\n  minmax <- readNumbersFromField(minmax)\n  for (lineNumber in  1:length(fileAddresses[[1]])){\n    dataFile <- fileAddresses$datapath[lineNumber]\n    if (usingExcel){\n      if (dataFile==\"./RR.csv\") dataFile=\"./RR.xlsx\" # just making sure that the XLConnect does not crash on text\n      tryCatch(\n        wb <- loadWorkbook(dataFile),\n        error = function(e) javaerror <<- TRUE # if java fails, \"bullshit\" will be returned and it should be handled in reactive plot\n      )\n      if (javaerror) return(data.frame(Info = \"FAIL - incorrect format - try choosing another file format, column selection or separator\"))\n      data <- readWorksheet(wb, sheet = 1) # this will never happen if java fails\n    } else {\n      tryCatch(\n        data <- read.csv(dataFile, sep = separator, header = T),\n        warning = function(e) csverror <<- TRUE # because here we do get a warning, rather than an error\n      )\n    }\n    if (csverror) return(data.frame(Info = \"FAIL - incorrect format - try choosing another file format, column selection or separator\"))\n    RR <- data[[RR_idx]]\n    if (flag_idx>0)\n      flags <- data[[flag_idx]]\n    else\n      flags <- RR*0\n    # time based filtering here\n    which_min <- RR <= minmax[1]\n    which_max <- RR >= minmax[2]\n    flags[which_min] <- 2\n    flags[which_max] <- 3\n    tryCatch(\n    tryCountingRuns <- countForAll(RR, flags),\n    error = function(e) tryCountingRuns <<- NA\n    )\n    if (is.na(tryCountingRuns[1])) return(data.frame(Info = \"FAIL - incorrect format - try choosing another file format, column selection or separator\"))\n    else results <- c(results, list(tryCountingRuns))\n  }\n  lenUp <- 0; lenDown <- 0; lenNoChange <- 0\n  ## in this loop I am getting the maximum run length of a scpecific type for the analysed group of recordings\n  for (result in results){\n    if (length(result$directionup) > lenUp) lenUp <- length(result$directionup)\n    if (length(result$directiondown) > lenDown) lenDown <- length(result$directiondown)\n    if (length(result$noChange) > lenNoChange) lenNoChange <- length(result$noChange)\n  }\n  \n  finalResults <- data.frame()\n  for (result in results){\n    finalResults <- rbind(finalResults, c(result$directionup[1:lenUp], result$directiondown[1:lenDown], result$noChange[1:lenNoChange]))\n  }\n  finalResults <- cbind(fileAddresses$name,finalResults)\n  computedNames <- c(\"file\", \n                     paste(\"up\", 1:lenUp, sep = \"\"),\n                     paste(\"down\", 1:lenDown, sep = \"\"))\n  if(lenNoChange > 0){\n                     computedNames <- c(computedNames,paste(\"no change\", seq_len(lenNoChange), sep = \"\"))\n  }\n  ### computing column names (i.e. how many \"Up\"'s, \"Down\"'s etc.)\n  #print(computedNames)\n  #print(finalResults)\n  colnames(finalResults) <- computedNames\n  ### and finally replacing NA's by zeros, so that it is easier to process (in fact, count 0 is obviously no NA, as 0 is a valid number of runs)\n  finalResults[is.na(finalResults)] <- as.integer(0)\n  return(finalResults)\n}\n\ngetSep <- function(separator){\n  sep = separator\n  if (separator == \"tabulator\"){\n    sep = \"\\t\"\n  }\n  if (separator == \"space\"){\n    sep = \" \"\n  }\n  return(sep)\n}\n\nshinyServer(function(input, output){\n  dataAddress <- reactive({\n    dataPaths <- data.frame(name = c(\"RR.csv\"), size = 0, type = c(\"text/plain\"), datapath = c(\"./RR.csv\"), stringsAsFactors = FALSE)\n    if (!is.null(input$files)){\n      dataPaths <- input$files\n    }\n    return(dataPaths)\n  })\n  \n  # reactive conductor for runs\n  currentRuns <- reactive({\n    errorOnRead <- FALSE\n    tryCatch(\n      runsResults <- getRunsResults(dataAddress(), sep = getSep(input$separator), input$data_columns,  input$minmax, input$usingExcel),\n      error = function(e) errorOnRead <<-  TRUE\n    )\n    if (errorOnRead){\n      runsResults <- data.frame(Info = \"FAIL - incorrect format - try choosing another file format, column selection or separator\")\n    }\n    return(runsResults) \n    })\n  \n  output$filesRunsView <- renderTable({\n  currentRuns()    \n  }, include.rownames = FALSE)\n  \n  output$downloadResults <- downloadHandler(\n    filename = \"RunsResults.xlsx\",\n    content = function(file) {\n      writeWorksheetToFile( file = file, data=currentRuns(), sheet=\"Runs distribution\")\n    })\n  ### end of server below\n}\n)\n",
    "created" : 1497385555510.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "956277518",
    "id" : "13FE42F4",
    "lastKnownWriteTime" : 1523348033,
    "last_content_update" : 1523348033644,
    "path" : "~/Dropbox/Praca/software/opengranary_apps/HRV/runs/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}