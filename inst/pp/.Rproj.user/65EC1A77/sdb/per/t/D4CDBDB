{
    "collab_server" : "",
    "contents" : "### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n### GNU General Public License for more details.\n\n### You should have received a copy of the GNU General Public License\n### along with PP.  If not, see <http://www.gnu.org/licenses/>.\n### PP is free software: you can redistribute it and/or modify\n### it under the terms of the GNU General Public License as published by\n### the Free Software Foundation, either version 3 of the License, or\n### (at your option) any later version.\n\n### PP is distributed in the hope that it will be useful,\n### but WITHOUT ANY WARRANTY; without even the implied warranty of\n### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n### GNU General Public License for more details.\n\n### You should have received a copy of the GNU General Public License\n### along with PP.  If not, see <http://www.gnu.org/licenses/>.\n\nlibrary(shiny)\nlibrary(XLConnect)\n### switching off the scientific notation\noptions(scipen=999)\n### so that the rnorm function is called only once during the session\n### these are the starting values of the application\nsource(\"HRA.R\")\n\n### plot for download\nreadNumbersFromField <- function(listArgument){\n  listOfNamesAndNumbers <- paste(strsplit(listArgument, \",\")[[1]], collapse=\".\")\n  listOfNamesAndNumbers <- strsplit(listOfNamesAndNumbers,\" \")[[1]]\n  nazwa <- \"\"\n  myLengthosc <- length(listOfNamesAndNumbers)\n  for (element in 1:myLengthosc){\n    if (is.na(as.numeric(listOfNamesAndNumbers[element]))) nazwa <- paste(nazwa, listOfNamesAndNumbers[element])\n    else break\n  }\n  listOfNumbers <- listOfNamesAndNumbers[element:myLengthosc]\n  myData <- as.vector(sapply(listOfNumbers, as.numeric))\n  return(myData)\n}\n\nplotInput <- function(data1, data2, col, variableName){\n  tempPP <- preparePP(data1, data2)\n  xlab = parse(text = paste(variableName, \"[i]\"))\n  ylab = parse(text = paste(variableName, \"[i+1]\"))\n  plot(tempPP[,2]~tempPP[,1], xlab = xlab, ylab = ylab, pch = 21, col = \"black\", bg = col)\n  abline(0,1, lty = 2, lwd = 2)\n}\n\nread_and_filter_one_file <- function(fileAddresses, lineNumber, separator, column_data, minmax, usingExcel){\n  dataFile <- fileAddresses$datapath[lineNumber]\n  javaerror <- FALSE; csverror <- FALSE # these show whether the function should return \"some_problem\" and exit\n  if (usingExcel){\n    if (dataFile==\"./RR.csv\") dataFile=\"./RR.xlsx\" # just making sure that the XLConnect does not crash on text\n    tryCatch(\n    wb <- loadWorkbook(dataFile),\n    error = function(e) javaerror <<- TRUE # if java fails, \"some_problem\" will be returned and it should be handled in reactive plot\n    )\n    if (javaerror) return(data.frame(\"some_problem\"))\n    data <- readWorksheet(wb, sheet = 1) # this will never happen if java fails\n  } else {\n    data <- read.csv(dataFile, sep = separator, header = T, row.names=NULL)\n  }\n  column_idx <- readNumbersFromField(column_data)\n  RR_idx <- column_idx[1]\n  flag_idx <- ifelse(length(column_idx)>1, column_idx[2], 0)\n  tryCatch( # this will go wrong if the wrong type of file is selected\n    RR <- data[[RR_idx]],\n    error = function(e) csverror <<- TRUE  # i just return some_problem and it should be handled in the reactive plot\n  )\n  if (csverror) return(data.frame(\"some_problem\"))\n  if (flag_idx>0){\n    tryCatch( # now, an error can also happen if there is a flags column, but it does not correspond to an actual column flag\n    flags <- data[[flag_idx]],\n    error = function(e) csverror <<- TRUE\n    )\n    if (csverror) return(data.frame(\"some_problem\")) # if this happens, return some_problem\n  }\n  else\n    flags <- RR*0\n  # time based filtering here\n  minmax <- readNumbersFromField(minmax)\n  which_min <- RR <= minmax[1]\n  which_max <- RR >= minmax[2]\n  flags[which_min] <- 2\n  flags[which_max] <- 3\n  return(list(RR=RR, flags=flags))\n}\ngetPpResults <- function(fileAddresses, separator = \"\\t\", column_data, minmax, usingExcel){\n  results <- c()\n  for (lineNumber in  1:length(fileAddresses[[1]])){\n    rr_and_flags <- read_and_filter_one_file(fileAddresses, lineNumber, separator, column_data, minmax, usingExcel)\n    tempPP <- preparePP(rr_and_flags[[1]], rr_and_flags[[2]])\n    results <- rbind(results, HRAdescriptors(tempPP))\n  }\n  results <- round(results,3)\n  results <- cbind(fileAddresses$name, results)\n  colnames(results) <- c(\"file\", \"SD1\", \"SD2\", \"SDNN\", \"SD1d\", \"SD1a\", \"C1d\", \"SD2d\", \"SD2a\", \"C2d\", \"SDNNd\", \"SDNNa\", \"Cd\")\n  return(results)\n}\n\ngetSep <- function(separator){\n  sep = separator\n  if (separator == \"tabulator\"){\n    sep = \"\\t\"\n  }\n  if (separator == \"space\"){\n    sep = \" \"\n  }\n  return(sep)\n}\n\nshinyServer(function(input, output){\n  dataAddress <- reactive({\n    dataPaths <- data.frame(name = c(\"RR.csv\"), size = 0, type = c(\"text/plain\"), datapath = c(\"./RR.csv\"), stringsAsFactors = FALSE)\n    if (!is.null(input$files)){\n      dataPaths <- input$files\n    }\n    return(dataPaths)\n  })\n  \n  output$plot <- renderPlot({\n    errorOnRead <- FALSE\n    rr_and_flags <- read_and_filter_one_file(dataAddress(), 1, separator=getSep(input$separator), input$data_columns, input$minmax, input$usingExcel)\n    tryCatch(\n      tempPP <- preparePP(rr_and_flags[[1]], rr_and_flags[[2]]),\n      error = function(e) errorOnRead <<-  TRUE\n     )\n    tryCatch(\n      drawPP(tempPP, variableName = ifelse(input$variableName==\"\", \"RR\", input$variableName), color = input$color),\n      error = function(e)   errorOnRead <<- TRUE\n    )\n    if (errorOnRead){\n     plot(1:10, 1:10, col = \"white\")\n      text(6,7, \"Fail - incorrect format\", cex = 1.5)\n      text(6,5, \"try another file type,\", cex = 1.5)      \n      text(6,3, \"column selection, or separator\", cex = 1.5)      \n    } else {\n    drawPP(tempPP, variableName = ifelse(input$variableName==\"\", \"RR\", input$variableName), color = input$color)\n    }\n  })\n  \n  # now reactive conductor holding the results of Poincare plot calculations\n  \n  currentPPvalues <- reactive({\n    tryCatch(\n    returnTable <- getPpResults(dataAddress(), sep = getSep(input$separator), input$data_columns, input$minmax, input$usingExcel),\n    error = function(e) returnTable <<- NA\n  )\n    if (is.na(returnTable[1])) return(data.frame(Info = \"FAIL - incorrect format - try choosing another file type, column selection or separator\"))\n    else return(returnTable)})\n  \n  output$filesView <- renderTable({\n  return(currentPPvalues())\n  }, include.rownames = FALSE)\n  \n  output$myDataView <- renderTable({\n    X <- input$variableName\n    myTable <- data.frame(myData()[[1]], transformData()$data)\n    colnames(myTable) <- c(input$variableName, \"transformation\")\n    myTable\n  })\n  \n  output$downloadPlot <- downloadHandler(\n    filename = \"PoincarePlot.png\",\n    content = function(file) {\n    rr_and_flags <- read_and_filter_one_file(dataAddress(), 1, separator=getSep(input$separator), input$data_columns, input$minmax, input$usingExcel)\n    png(file, width=1800, height = 1900, res=300)\n    plotInput(rr_and_flags[[1]], rr_and_flags[[2]], input$color, input$variableName)\n    dev.off()\n  })\n\n  output$downloadResults <- downloadHandler(\n    filename = \"PPResults.xlsx\",\n    content = function(file) {\n      writeWorksheetToFile( file = file, data=currentPPvalues(), sheet=\"Poincare plot\")\n    })\n\n  ### end of server below\n}\n)\n\n",
    "created" : 1506088486657.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2284614583",
    "id" : "D4CDBDB",
    "lastKnownWriteTime" : 1523347902,
    "last_content_update" : 1523347902590,
    "path" : "~/Dropbox/Praca/software/opengranary_apps/HRV/pp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}